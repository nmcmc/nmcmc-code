---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
from scipy.constants import neutron_mass
# %load_ext autoreload
# %autoreload 2
```

```{python}
import torch
import numpy as np
import time
import matplotlib.pyplot as plt    
```

```{python}
torch.__version__
```

```{python}
import neumc
```

```{python}
from neumc.training.train import train_step
```

```{python}
from neumc.training.loss import rt_loss, REINFORCE_loss
```

```{python}

from neumc.nf.u1_model_asm import assemble_model_from_dict
```

```{python}
import neumc.physics.u1 as u1
import neumc.physics.schwinger as sch
from neumc.utils import grab
import neumc.nf.flow as nf
```

```{python}
torch.__version__
```

```{python}
torch.cuda.is_available()
```

```{python}
for dev in range(torch.cuda.device_count()):
    print(torch.cuda.get_device_properties(dev))
```

```{python}
torch_device="cuda:0"
float_dtype="float32"
```

```{python}
torch.cuda.get_device_properties(torch_device)
```

```{python}
L = 8
lattice_shape = (L,L)
link_shape = (2,L,L)
beta = 2.0
kappa = 0.276
qed_action =  sch.QEDAction(beta, kappa)
```

```{python}
n_layers = 48
hidden_sizes = [64,64]
kernel_size = 3
n_knots=7

model_cfg = {'n_layers': 48,
                 'masking': '2x1',
                 'coupling': 'cs',
                 'nn': {
                     'hidden_channels': [64, 64],
                     'kernel_size': 3,
                     'dilation': [1, 2, 3],
                 },
                 'n_knots': 9,
                 'float_dtype': 'float32',
                 'lattice_shape': lattice_shape
                 }
```

```{python}
functions={}
L = 8 
lattice_shape = (L,L)
model_cfg = {'n_layers': 48,
                 'masking': '2x1',
                 'coupling': 'cs',
                 'nn': {
                     'hidden_channels': [64, 64],
                     'kernel_size': 3,
                     'dilation': [1, 2, 3],
                 },
                 'n_knots': 9,
                 'float_dtype': 'float32',
                 'lattice_shape': lattice_shape
                 }
for lfn in ["rt", "REINFORCE"]:
    loss_fn = globals()[f"{lfn}_loss"]
    model = assemble_model_from_dict(model_cfg, device=torch_device, verbose=1)
    
    layers = model['layers']
    prior = model['prior']
    z = prior.sample_n(8)
    log_prob_z = prior.log_prob(z)
    
    l, logq, logp = loss_fn(z, log_prob_z, model=model, action=qed_action, use_amp=False)
    
    
    d, h  = neumc.utils.profile.walk_(l.grad_fn, hook=neumc.utils.profile.GetNamesWalkHook())
    functions[lfn]=h.fn_counts

```

```{python}
L = 8
lattice_shape = (L,L)
model_cfg = {'n_layers': 48,
                 'masking': '2x1',
                 'coupling': 'cs',
                 'nn': {
                     'hidden_channels': [64, 64],
                     'kernel_size': 3,
                     'dilation': [1, 2, 3],
                 },
                 'n_knots': 9,
                 'float_dtype': 'float32',
                 'lattice_shape': lattice_shape
                 }
for lfn in ["rt", "REINFORCE"]:
    loss_fn = globals()[f"{lfn}_loss"]
    model = assemble_model_from_dict(model_cfg, device=torch_device, verbose=1)
    
    layers = model['layers']
    prior = model['prior']
    z = prior.sample_n(128)
    log_prob_z = prior.log_prob(z)
    
    l, logq, logp = loss_fn(z, log_prob_z, model=model, action=qed_action, use_amp=False)
    tot, timings = neumc.utils.profile.time(l, names=[])
    print(tot)
    neumc.utils.profile.pprint(neumc.utils.profile.order_by_time(neumc.utils.profile.collect_by_name(timings)))
```

```{python}
tree_sizes = {}
for lfn in ["rt", "REINFORCE"]:
    loss_fn = globals()[f"{lfn}_loss"]
    out =[]
    for L in [4, 8,12,16,20,24,28, 32]:
        model_cfg['lattice_shape']=(L,L)
        model= assemble_model_from_dict(model_cfg, device=torch_device, verbose=0)
    
        layers = model['layers']
        prior = model['prior']
    
        z = prior.sample_n(8)
        log_prob_z = prior.log_prob(z)
    
        l, logq, logp = loss_fn(z, log_prob_z, model=model, action=qed_action, use_amp=False)
    
        d, h = neumc.utils.profile.walk_(l.grad_fn, hook=neumc.utils.profile.CountWalkHook())
        c = h.count
        out.append((L,c,d))
    out_a = np.array(out)
    tree_sizes[lfn]=out_a
```

```{python}
p = np.polyfit(tree_sizes['rt'][:,0], tree_sizes['rt'][:,1],2);
p
```

```{python}
xs = np.linspace(0,34,100)
plt.scatter(tree_sizes['rt'][:,0], tree_sizes['rt'][:,1]);
plt.plot(xs, np.polyval(p,xs));
plt.scatter(tree_sizes['REINFORCE'][:,0], tree_sizes['REINFORCE'][:,1]);
plt.savefig("tree_size.pdf")
```
